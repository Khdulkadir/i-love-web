export const posts = [
  // {
  //   slug: 'we-love-web-gemert',
  //   title: 'We Love Web - Gemert',
  //   date: '13 September 2024',
  //   content: 'Here is some more content for another blog post. You can add more as needed!'
  // },
  {
    slug: 'sprint-13',
    title: 'Sprint 13',
    date: '20 September 2024',
  content: "<p><b>Wat is SvelteKit en hoe installeer je het?</b></p>SvelteKit is een modern framework voor het bouwen van webapplicaties met Svelte als basis. Het verschilt van traditionele JavaScript-frameworks zoals React of Vue doordat het veel optimalisaties doet tijdens de buildtijd, wat resulteert in lichtere en snellere applicaties. SvelteKit biedt onder andere ingebouwde routering, server-side rendering (SSR), en client-side rendering (CSR), waardoor het een flexibele keuze is voor moderne webapplicaties.<p>Om SvelteKit te installeren, gebruik je de volgende stappen:</p>1. Zorg dat Node.js is geïnstalleerd.<br>2. Maak een nieuw project met het volgende commando:<br><code>npm create svelte@latest</code><br>3. Volg de instructies in de terminal om het project te configureren en de benodigde dependencies te installeren. Zodra het project klaar is, kun je de applicatie lokaal starten met <code>npm run dev</code>.<p><b>Hoe SvelteKit GET en POST afhandelt</b></p>In SvelteKit worden GET en POST-verzoeken gebruikt om gegevens tussen de client en de server te verzenden en op te halen. Deze verzoeken worden meestal afgehandeld via speciale functies in een server.js-bestand of in de load-functie van een component.<p>GET-verzoeken worden gebruikt om data van de server op te halen. Bijvoorbeeld om content te laden zodra de pagina wordt geopend.<br>POST-verzoeken worden gebruikt om data naar de server te sturen, zoals bij het invullen van een formulier. In SvelteKit maak je hiervoor een formulier met een POST-methode, en het server.js-bestand verwerkt dit verzoek en geeft een antwoord terug aan de client.<p><b>De mappenstructuur van SvelteKit</b></p>SvelteKit heeft een duidelijke mappenstructuur die helpt bij het organiseren van de verschillende onderdelen van een project:<br>- <code>src/routes</code>: Hierin staan de pagina's van de applicatie, die worden aangemaakt als .svelte-bestanden.<br>- <code>src/lib</code>: Hier kunnen herbruikbare componenten en functies geplaatst worden.<br>- <code>static</code>: Dit is de map voor statische bestanden zoals afbeeldingen en fonts.<br>- <code>src/routes/api</code>: Voor API-routes die server-side functionaliteit afhandelen.<p><b>Bestandstypes in SvelteKit</b></p>In een SvelteKit-project kom je verschillende bestandstypen tegen:<br>- <code>.svelte</code>: Dit zijn componenten die zowel HTML, CSS als JavaScript kunnen bevatten.<br>- <code>.js</code>: Scriptbestanden voor logica buiten de componenten, zoals helpers of API-afhandeling.<br>- <code>server.js</code>: Dit bestand bevat server-side logica en functies om verzoeken (zoals GET en POST) af te handelen.<p><b>Hoe layout.svelte en server.js werken in SvelteKit</b></p>- <code>layout.svelte</code>: Dit bestand wordt gebruikt voor de lay-out van de applicatie, bijvoorbeeld de header, footer of navigatie die op meerdere pagina's hetzelfde blijft. De layout.svelte-component is als een sjabloon die over de pagina’s heen ligt.<br>- <code>server.js</code>: Dit bestand wordt gebruikt voor server-side logica. Het kan gegevens verwerken die de client verstuurt, zoals formulierdata, en terugsturen naar de client. Ook kan het data ophalen uit een database en deze teruggeven als JSON.<p><b>Hoe CSR en SSR werken in SvelteKit</b></p>Client-Side Rendering (CSR): De rendering gebeurt volledig aan de kant van de gebruiker (de browser). Dit kan resulteren in snellere overgangen tussen pagina’s, maar minder optimalisatie voor zoekmachines.<br>Server-Side Rendering (SSR): De pagina’s worden vooraf op de server gerenderd en vervolgens aan de client gegeven. Dit zorgt voor snellere laadtijden en een betere SEO. SvelteKit biedt een hybride model waarin SSR en CSR samen kunnen worden gebruikt voor een optimale gebruikerservaring.<p><b>Epics, User Stories en Tasks</b></p>Om projecten te organiseren, gebruiken we epics, user stories en tasks:<br>- Epic: Een groot onderdeel van een project. Een epic kan bijvoorbeeld 'Detailpagina' zijn.<br>- User Story: Een beschrijving van een functie vanuit het perspectief van de gebruiker. Bijvoorbeeld, 'Als gebruiker wil ik kunnen inloggen zodat ik toegang krijg tot mijn profiel.'<br>- Task: Specifieke taken om een user story te realiseren. Voor de user story over inloggen kan een taak zijn: 'Maak een inlogformulier aan.'<p><b>De MoSCoW-methode</b></p>We hebben ook de MoSCoW-methode besproken, die wordt gebruikt om prioriteiten te stellen binnen een project. De afkorting staat voor:<br>- Must Have: Cruciale onderdelen zonder welke het project niet succesvol kan zijn.<br>- Should Have: Belangrijke functies, maar niet noodzakelijk voor de basiswerking.<br>- Could Have: Optionele functies die waarde toevoegen als er tijd over is.<br>- Won't Have (for now): Functionaliteit die niet in de huidige versie komt, maar wellicht later wordt toegevoegd.<p>Door deze methode toe te passen, kun je gestructureerd werken en de belangrijkste functionaliteiten van een project voorrang geven."
	},
	// {
	// 	slug: 'we-love-web-garnier',
	// 	title: 'We Love Web - Garnier',
	// 	date: '4 Oktober 2024',
  //   content: 'This is the content of my first blog post. It\'s simple text without markdown.'
  // },
  {
    slug: 'sprint-14',
    title: 'Sprint 14',
    date: '11 Oktober 2024',
		content: "<p><strong>Wat is JAMstack, een Site Generator, en Headless CMS?</strong></p>\nJAMstack is een moderne architectuur voor websites en webapplicaties waarbij de nadruk ligt op het gebruik van JavaScript, API's, en Markup. Deze benadering maakt de applicatie snel, schaalbaar en veiliger omdat er geen traditionele servers of databases direct nodig zijn. \n\nEen site generator is een tool die vooraf alle pagina’s van een website omzet in statische HTML-bestanden. Dit zorgt ervoor dat de website snel laadt en makkelijker te beheren is. Populaire generators zijn bijvoorbeeld Sveltekit en Astro.\n\nEen headless CMS (Content Management System) is een CMS zonder gekoppelde front-end; het levert de content via een API aan de front-end die het vervolgens zelf weergeeft. Bekende headless CMS-systemen zijn Directus en Hypraph.\n\n<p><strong>Hoe routing werkt in SvelteKit en de benodigde bestanden</strong></p>\nIn SvelteKit wordt routing automatisch opgezet op basis van de mapstructuur binnen <code>src/routes</code>. Elke bestandsnaam en map binnen deze directory stelt een route voor. Zo wordt <code>src/routes/index.svelte</code> bijvoorbeeld de startpagina ('/'), en maakt <code>src/routes/about.svelte</code> een route aan voor '/about'. Door bestanden en mappen te structureren, kunnen routes zonder veel handmatige configuratie worden aangemaakt.\n\n<p><strong>Error Handling met error.svelte</strong></p>\nIn SvelteKit kan de <code>error.svelte</code> component gebruikt worden om foutmeldingen op een nette manier af te vangen en weer te geven. Als er bijvoorbeeld een 404-fout of een serverfout optreedt, kan SvelteKit automatisch <code>error.svelte</code> renderen met de foutinformatie. Zo kan je betere foutafhandeling en een overzichtelijkere gebruikservaring creëren.\n\n<p><strong>Wat is Binding?</strong></p>\nBinding in Svelte betekent dat je een element of variabele automatisch kunt synchroniseren met de waarde in de component, bijvoorbeeld een invoerveld. Dit wordt 'two-way binding' genoemd. Als een gebruiker een waarde invoert, wordt deze automatisch geüpdatet in de component, en omgekeerd.\n\n<p><strong>Waar de Library voor is</strong></p>\nIn SvelteKit bevat de <code>src/lib</code> map herbruikbare componenten, functies en modules. Dit helpt om code georganiseerd en herbruikbaar te houden en maakt samenwerking tussen verschillende onderdelen van het project eenvoudiger.\n\n<p><strong>Wat zijn Componenten?</strong></p>\nComponenten zijn herbruikbare stukjes UI die samen een webapplicatie vormen. In Svelte worden deze componenten opgeslagen in <code>.svelte</code> bestanden. Een component kan alles bevatten wat nodig is om zichzelf te renderen en interactief te maken, inclusief HTML, CSS en JavaScript.\n\n<p><strong>Wat is Agile en hoe werkt het?</strong></p>\nAgile is een methode voor projectmanagement die vooral bij softwareontwikkeling wordt gebruikt. Het Agile-proces verdeelt werk in kleine, beheersbare eenheden en focust op continue feedback en verbeteringen. Agile werkt met iteratieve sprints, waarbij het team snel werkbare onderdelen van het project oplevert. Deze aanpak helpt om snel te reageren op veranderingen en aanpassingen aan het product te maken.\n\n<p><strong>Planning Poker</strong></p>\nPlanning Poker is een techniek binnen Agile waarmee teams gezamenlijk inschattingen kunnen maken over de tijd en moeite die nodig zijn voor bepaalde taken. Teamleden gebruiken kaarten met getallen om een inschatting te geven. Vervolgens bespreken ze hun keuzes en komen ze tot een gezamenlijke schatting. Dit bevordert de samenwerking en zorgt voor een realistische planning.\n\n<p><strong>Scrum, Scrum Master en Sprint</strong></p>\nScrum is een specifieke Agile-methode waarin werk in sprints wordt opgedeeld. Een sprint is een vaste periode waarin een deel van het project wordt voltooid. De Scrum Master is de persoon die het Scrum-proces begeleidt en ervoor zorgt dat het team zich aan de afspraken houdt. Hij of zij verwijdert obstakels en zorgt ervoor dat het team optimaal kan presteren.\n\n<p><strong>Stakeholders</strong></p>\nStakeholders zijn de personen of groepen die betrokken zijn bij het project en een belang hebben bij de uitkomst ervan. Dit kunnen klanten, gebruikers, managers of andere belanghebbenden zijn. Stakeholders leveren input en feedback, wat van invloed is op de prioriteiten en richting van het project.\n\n<p><strong>Velocity</strong></p>\nVelocity is een maatstaf die binnen Agile wordt gebruikt om de hoeveelheid werk die een team kan afronden binnen een sprint te meten. Het helpt om toekomstige sprints beter te plannen door een idee te geven van de gemiddelde capaciteit van het team."
  },
    {
    slug: 'sprint-15',
    title: 'Sprint 15',
    date: '25 Oktober 2024',
		content: "<p><strong>Gebruikerservaring (User Experience)</strong></p>\nEen van de belangrijkste factoren bij het kiezen van een tech stack is de eindgebruikerservaring. De technologie die je kiest, moet gebruikers een vlotte, intuïtieve en snelle ervaring bieden. Je kunt bijvoorbeeld technologieën selecteren die:</p>\n<ul>\n<li>Snelheid en responsiviteit bevorderen, zoals frameworks die server-side rendering ondersteunen of lichte JavaScript-bibliotheken.</li>\n<li>Geoptimaliseerd zijn voor mobiel gebruik, aangezien veel gebruikers websites op mobiele apparaten bezoeken.</li>\n<li>SEO-vriendelijk zijn, zoals frameworks die server-side rendering (SSR) ondersteunen om beter te scoren in zoekmachines.</li>\n</ul>\n\n<p><strong>Content Management Ervaring</strong></p>\nVoor het contentbeheerteam moet de tech stack ook makkelijk in gebruik zijn. Een headless CMS kan bijvoorbeeld een goede keuze zijn, omdat het content van de presentatie loskoppelt. Zo kan content eenvoudig worden bewerkt en gedeeld via verschillende kanalen (zoals web en mobiele apps). Factoren om rekening mee te houden zijn:\n<ul>\n<li>Gebruikersvriendelijkheid van het CMS en de interface voor beheerders.</li>\n<li>Integratiemogelijkheden met andere tools en API’s.</li>\n<li>Flexibiliteit en ondersteuning voor workflows, zodat verschillende gebruikers tegelijkertijd kunnen samenwerken.</li>\n</ul>\n\n<p><strong>Developer Experience</strong></p>\nDe ervaring van het ontwikkelteam speelt ook een grote rol bij het kiezen van een tech stack. Een goede tech stack maakt het ontwikkelproces efficiënter en biedt mogelijkheden voor schaalbaarheid en samenwerking. Factoren om te overwegen zijn onder andere:\n<ul>\n<li>Beschikbaarheid van goede documentatie en community-ondersteuning.</li>\n<li>Compatibiliteit met bestaande tools en technologieën binnen het team.</li>\n<li>Beschikbaarheid van kant-en-klare componenten en modules die de ontwikkeling versnellen.</li>\n</ul>\n\n<p><strong>Waar moet je op letten bij het kiezen van een Tech Stack?</strong></p>\nBij het kiezen van een tech stack moet je rekening houden met:\n<ul>\n<li><strong>Projectdoelen:</strong> Wat wil je bereiken? Welke gebruikersfunctionaliteiten zijn essentieel?</li>\n<li><strong>Schaalbaarheid:</strong> Kan de stack meegroeien met het project en toekomstige eisen aan?</li>\n<li><strong>Onderhoudbaarheid:</strong> Is het gemakkelijk om de stack te updaten en nieuwe functies toe te voegen?</li>\n<li><strong>Kosten:</strong> Past de gekozen technologie binnen het budget, inclusief licenties, hosting, en onderhoudskosten?</li>\n</ul>\n\n<p><strong>Argumentatieschema voor Tech Stack Keuze</strong></p>\nOm een tech stack goed te onderbouwen, kan je een argumentatieschema gebruiken. Dit helpt om keuzes gestructureerd te verantwoorden en mogelijke tegenargumenten mee te nemen. Een voorbeeld van een argumentatieschema kan zijn:\n<ul>\n<li><strong>Stelling:</strong> “We kiezen voor een headless CMS in combinatie met een JAMstack omdat dit de prestaties verbetert en gebruikers sneller toegang geeft tot content.”</li>\n<li><strong>Argument:</strong> “Een headless CMS maakt het mogelijk om content onafhankelijk van de front-end te beheren, waardoor content flexibel over verschillende platforms verspreid kan worden.”</li>\n<li><strong>Onderbouwing:</strong> “Uit onderzoek blijkt dat het gebruik van een headless CMS tot 30% kortere laadtijden kan leiden in vergelijking met traditionele CMS-oplossingen.”</li>\n<li><strong>Tegenargument:</strong> “Een headless CMS kan complexer zijn om op te zetten en vergt meer ontwikkeling van de front-end.”</li>\n<li><strong>Weerlegging:</strong> “Door te kiezen voor een ervaren ontwikkelteam en een framework met kant-en-klare componenten, kunnen we de complexiteit en implementatietijd minimaliseren.”</li>\n</ul>"
  },
];